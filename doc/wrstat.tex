\section{wrstat}

\subsection{Description}
    Wrstat is a modularized performance analysis tool to collect
    system information of different types and origins.
    It makes use of the /proc file system or uses third party tools
    to gather information on CPU, kernel lock and disk usage.
    It is mostly written in Python because its wide availability,
    easy and powerful syntax.
    There are implemented modules for e.g OProfile, iostat and lock\_stat.
    It has also support for sampling, which allows to capture time series data.

\subsection{Installation}
    For a basic installation, you have to perform the following steps
    \begin{enumerate}
        \item Copy the wrstat directory to your Installation path 
        \item Link wrstat-run to e.g. /usr/local/bin
        \item Create wrstat.config based on the given template
    \end{enumerate}

    \subsection{wrstat.config}
    The wrstat.config file contains the main tool and module configuration.
    To run wrstat, the following options are required:

    \begin{description}
        \item[modules]
            Space separated list of modules invoked by wrstat.
            Modules will be called in the same order as supplied,
            except for the sampling.
        \item[runasroot]
            If true, the daemon will be called by sudo to
            give it root privileges. This is required for some modules
            as for OProfile and lock\_stat.
        \item[interval]
            Time span between samples.
    \end{description}

\subsection{Usage}
	To run a test program run:

    \begin{lstlisting}
        wrstat-run path/to/test/directory program args ..
    \end{lstlisting}

	While running a test, wrstat-daemon.py will invoke several
	modules to collect data of different type. The modules to run are
	specified in wrstat.config.

    Wrstat implements the following modules\\

    \begin{tabular}{l|l}
        Name & Description \\
        \hline
        stat		&Handles /proc/stat\\
        diskstats	&Handles /proc/diskstats\\
        lock\_stat	&Handles /proc/lock\_stat\\
        oprofile	&Wrapper and visualization for OProfile\\
        iostat		&Disk I/O throughput (deprecated)\\
    \end{tabular}

    When the test program finished, the collected data will be parsed
	by wrstart-parser.py and exported to samples.pickle.
    This data will then be graphed by wrstat-graph.py
    All steps are triggered by the wrstat-run main script.

\subsection{Test Directory Structure}
    This directory contains all test data and graphs.
    If the test directory does not exists it will be created,
    otherwise the results will been overwritten.
    This directory contains by default the following files:

    \begin{description}
        \item[wrstat.config]
            Snapshot of wrstat.config took at the beginning
            of a test run.
            This file can be used by any module to store
            additional configuration parameters.
            All modules and scripts will use this file
            instead of the global one, so later changes
            for e.g. filtering will not affect all test runs.
        \item[cmd]
            The actual command that was evaluated.
        \item[output]
            Stdout and stderr of the test command.
        \item[time]
            Output of time command.
        \item[samples.pickle]
            Parsed data of all modules. This file is created by 
            wrstat-parser.py which contains a dictionary, that
            maps the module name on its data.
        \item[samples/]
            Directory that will be used for all modules to store raw
            samples, which are created by sample() method
        \item[*.svg]
            Multiple graphs generated by wrstat-graph.
    \end{description}

\subsection{Tool Directory Structure}
    Wrstat consists of the following 
    %TODO remove .py extensions
    \begin{description}
        \item[wrstat-run test\_dir cmd arg1 arg2 ...]
            This is the main program written in bash, that glues all components together.
            It creates the basic test directory structure, calls the actual test command
            and initiates pre- and postprocessing.

        \item[wrstat-filer-create list of ELF binaries > path/new\_filter]
            This script can be used to create custom symbol name filter for OProfile and lock\_stat.
            It uses objdump to extract the symbol table in .text from a list ELF binaries ( e.g. .ko files )
            of interest.
            This function names can be used to reduce output.
            To extract symbol names, non stripped binaries are required, but no debug information.


        \item[wrstat-daemon.py test\_dir]
            This program runs in background as long as the test command.
            It will first initiate all modules and signals wrstat-run to start the test.
            As the test runs it will invoke all modules to take samples at the interval
            specified in the config file and in the end deinitialize all modules.
            The actual sampling will just take raw snapshots of e.g. /proc files,
            to avoid lags and unnecessary CPU load.
            A delayed ( queued) copy mechanism from utils.py is used to avoid lags due to IO.

        \item[wrstat-parser.py test\_dir]
            This component will sanitize and parse the captured data and store the results in samples.pcikle.

        \item[wrstat-graph.py test\_dir]
            This will create actual graphs from samples.pickle using gnuplot.

        \item[graphing.py (Python module)]
            This simple python module has predefined methods for series and histogram graphs
            based on gnuplot.
            Per default it will create Scalable Vector Graphics ( .svg) output.

        \item[utils.py (Python module)]
            This module implements some basic functionality such as config, module loading
            and the delayed copy.

    \end{description}

\subsection{Modules}
    A modules is used to collect data from one specific origin,
	e.g. /proc/lock\_stat
	or OProfile, that provide the actual functionality.
    For additional configuration each module can add parameters to wrstat.config
    file.

	Each module is a python script containing the following methods:
    \begin{description}
        \item[def presampling( test\_dir):]
			This method is called once at the beginning of a test.
			It is usually used for initialization.

        \item[def sample( test\_dir, t):]
			This method is called with the specified interval
			and is used to take samples for any kind of time series
			data. To mitigate lag problems this each module has its own sampling thread
			to ensure stable sampling.
            The parameter t is the number of the current sample.
            In case of copying a file it is recommended to use the copy\_queued method
            from utils.py.
            %, which will read all data and append the to a io queue.
            %An extra thread is used to write those data to disk, to avoid lags
            %due to massive disk IO.

        \item[def postsampling( test\_dir):]
			This method is called once the test is finished.
			It can by used for any kind	
			of deinitialization or postprocessing.

        \item[def parse( test\_dir):]
			This method will be called by wrstat-parser.py
			and will parse and return the data captured by wrstat-daemon.
			
        \item[def plot( test\_dir, data, interval):]
			This method will be called by wrstat-graph and will create
			all needed graphs.
            The provided data was previously created by parse().
    \end{description}

	To make a module usable by wrstat, copy the script to the tool directory and
	add the module name to wrstat.config.
    The module name is the name of the file without extension.

\subsection{Deamon}
    Foremost the daemon will call each modules presampling() and then
    create individual threads for each module to avoid interference.
    To realize timing and thread synchronization the daemon uses a condition variable,
    which will be used by the the daemon as follows:

    \begin{description}
        \item[def sample( module, modname):]
            This is the actual sampling thread for a single module.
            It calls the module.sample() method and wait for the 
            condition variable to take the next sample.
        \item[def timer( interval):]
            This is the main thread which is responsible to keep a stable sampling rate.
            It will notify all threads waiting on the condition variable
            and sleep for the specified interval.
        \item[def signal\_handler( signal, frame):]
            This method will be called from the main thread,
            if a SIGINT or SIGTERM is received and signals all sampling threads to finish.
            To avoid zombie threads that are still waiting on the condition variable,
            it will notify all threads as long as there are threads alive.
            Finally int will call each modules postsampling() method.
    \end{description}

    The implementation of the queued ( and threaded) copy from utils.py is similar to the daemon,
    as it uses an extra thread for dumping the data from queue to disk, that is signaled at
    any copy.

\subsection{samples.pickle}
    This file contains all data parsed by wrstat and can be loaded by python using pickle
    for custom postprocessing.
    Such a file can be loaded (also from python prompt) by the following commands.

\begin{lstlisting}
import pickle #required only once
f = open( "test_dir/samples.pickle", 'r')                            
samples = pickle.load( f)
f.close()
\end{lstlisting}

    Writing works similar but uses "pickle.dump( samples, f)" instead of the load command.
    This file contains a nested array and dictionary structure, that is similar to JSON.
    The top level data structure maps the module name to the data returned by parse()
    and might look like the following:

\begin{lstlisting}
{
    "stat" : ... ,
    "iostat" : ... ,
    "oprofile" : ...
}
\end{lstlisting}
